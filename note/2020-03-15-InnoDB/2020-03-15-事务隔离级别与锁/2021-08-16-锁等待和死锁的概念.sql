

什么是死锁、什么是锁等待
锁等待：
    事务A 持有id=1的行锁，当事务B 也想要持有id=1的行锁，此时事务B会处于锁等待状态
    这时事务B可能会处于2种情况：
        1. 当事务A释放行锁，事务B就可以持有行锁。
        2. 如果处于锁等待状态超过一定阀值，事务B会被回滚。
		
		
死锁：
	2个或者2个以上的事务的锁资源形成了环路，进而触发了死锁检测。
    事务A 持有 id=1 的行锁                    事务B 持有 id=2的行锁
    事务A 申请持有id=2的行锁，被阻塞
                                              事务A 申请持有 id=1 的行锁，被阻塞
   从而触发了死锁检测，会回滚1个代价更小的事务，让其它被阻塞的事务继续运行。
   
   死锁是在锁等待的基础上触发的。
   
   
释放锁：
	大多数情况下事务锁都是在事务提交时释放，但有两种特殊情况：
		1. 自增锁语句执行结束释放或者申请完自增锁就释放;
		2. RC 隔离级别下，会把不符合where条件的记录锁释放，不需要等到事务提交才释放锁;
			-- 在RC隔离级别下执行DML语句时，从引擎层返回到Server层的记录，如果不满足where条件，则需要立刻unlock掉（ha_innobase::unlock_row）。
	除这两种情况外，其他的事务锁都是在事务提交时释放的。
	
	表级锁对象的释放调用函数lock_table_dequeue。

	注意在释放锁时，如果该事务持有的锁对象太多，每释放1000（LOCK_RELEASE_INTERVAL）个锁对象，会暂时释放下lock_sys->mutex再重新持有，防止InnoDB hang住。