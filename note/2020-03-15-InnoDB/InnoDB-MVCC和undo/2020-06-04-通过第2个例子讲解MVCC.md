1. read view的实现

   read view是一致性视图，它的实现逻辑是： InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在活跃的所有事务 ID

   活跃的定义： 已经启动但是没有提交的事务

   低水位和高水位：

   ​     低水位：数组里面事务 ID 的最小值记为低水位 对应 m_up_limit_id(min_trx_id)； 

   ​     高水位：数组里面事务 ID 的最大值记为记为高水位 对应 m_low_limit_id(max_trx_id；

    creator_trx_id ：表示 生成该read view的事务的事务id。

    m_ids：read view中所有的活跃事务ID列表。

   

2. 版本的可见性判断规则

   数据版本的可见性规则，就是基于数据的 `DATA_TRX_ID` (行记录的事务ID) 和这个一致性视图里面的活跃事务ID列表(`m_ids`)对比结果得到的，如下：

   准确的说就是基于数据的 row trx_id 跟一致性视图中的同一行记录的活跃事务ID的对比结果得到。

   1. 被访问版本的 DATA_TRX_ID 值与ReadView中的 creator_trx_id 值相同, 可见。

      一个数据版本， 对于一个事务视图来说， 除了自己的更新总是可见 即 当记录的 DATA_TRX_ID 和 事务创建者的 TRX_ID(creator_trx_id) 一样，记录可见。 # 理解

   2. 处于 `m_ids` 的有两种情况：

      在活跃事务列表中，说明未提交，不可见。 # 理解  

      不在活跃事务列表中， 在 m_ids 范围内， 表示这个版本是已经提交了的事务生成的，可见。 # 不理解，需要例子来验证下

   3. `min_trx_id`：当记录的 DATA_TRX_ID 小于 read view 中的 min_trx_id, 说明 是在视图创建之前已经提交, 可见。 # 理解

   4. `max_trx_id` : 大于此值的是未开启的事务， 不可见。

3. 表结构和数据的初始化

   `CREATE TABLE t1 (`
     `id int(11) NOT NULL,`
     `name char(10),`
     `age int(11) not null,`
     `PRIMARY KEY (id)`
   `) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;`

   `insert into t1 values(1,'a', 20);    # row trx_id=90;`

   `insert into t1 values(2,'b', 30);    # row trx_id=98;`

   `mysql> select * from t1;`
   `+----+------+-----+`
   `| id | name | age |`
   `+----+------+-----+`
   `|  1 | a    |  20 |`
   `+----+------+-----+`
   `1 row in set (0.00 sec)`

4. RR和RC隔离级别的实现

   假设：
   	1. 事务 A 开始前，系统里面只有一个活跃事务ID 是 99 即 m_ids 为 [99] ，需要注意的是：这个trx_id=99并不是t1.id=1这一行的版本号。
   	2. 三个事务开始前，(1,'a'，20) 这一行数据的 row trx_id 是 90。

   | 时刻点 | Transaction 100                    | 只读事务                        | 备注                                              |
   | ------ | ---------------------------------- | ------------------------------- | ------------------------------------------------- |
   |        | BEGIN;                             | BEGIN;                          | 历史版本1: trx_id = 90;  <br/>结果为(1, 'a', 20); |
   |        | update t1 set name='b' where id=1; |                                 | 当前版本:  trx_id = 100; <br/>结果为(1, 'b', 20); |
   | T1     |                                    | select name from t1 where id=1; | RC：return ''a"； <br />RR：return ''a"           |
   |        | COMMIT;                            |                                 |                                                   |
   | T2     |                                    | select name from t1 where id=1; | RC：return ''b"； <br />RR：return ''a"           |
   |        |                                    |                                 |                                                   |
   |        |                                    |                                 |                                                   |

  4.1 T1时刻在RC和RR隔离级别的返回值分析

​	READ COMMITTED——每次读取数据前都生成一个ReadView：

1. 只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。

2. 在执行SELECT语句时会先生成一个`read view`，`read view`的`m_ids`列表的内容为`[99, 100]`，`min_trx_id`为99，`max_trx_id`为100，`creator_trx_id`为0

3. 实际上通过 read view  判断行记录可见的时候， read view`的`m_ids`列表的内容为`[100]`， `min_trx_id`为100，`max_trx_id`为100，`creator_trx_id`为0；因为 trx_id=99 并不是t1.id=1这一行的版本号  # 这样理解感觉没毛病。

4. 然后从版本链中挑选可见的记录， 读数据都是从当前版本开始读取的，最新版本的列name的内容是'b'，该版本的trx_id值为100，在m_ids列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本

5. 下一个版本的列name的内容是'a'，该版本的trx_id值为90，小于ReadView中的min_trx_id值100，所以这个版本是符合要求的，最后返回给用户的版本就是这条name为 'a' 的记录。REPEATABLE READ——在第一次读取数据时生成一个ReadView

   <u></u>

​    REPEATABLE READ——在第一次读取数据时生成一个ReadView 

1. 只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。

2. 在执行SELECT语句时会先生成一个`read view`，`read view`的`m_ids`列表的内容为`[99, 100]`，`min_trx_id`为99，`max_trx_id`为100，`creator_trx_id`为0

3. 实际上通过 read view  判断行记录可见的时候， read view`的`m_ids`列表的内容为`[100]`， `min_trx_id`为100，`max_trx_id`为100，`creator_trx_id`为0； 因为 trx_id=99 并不是t1.id=1这一行的版本号  # 这样理解感觉没毛病。

4. 然后从版本链中挑选可见的记录， 读数据都是从当前版本开始读取的，最新版本的列name的内容是'b'，该版本的trx_id值为100，在m_ids列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本

5. 下一个版本的列name的内容是'a'，该版本的trx_id值为90，小于ReadView中的min_trx_id值100，所以这个版本是符合要求的，最后返回给用户的版本就是这条name为 'a' 的记录。

   

 4.2 T2时刻在RC和RR隔离级别的返回值分析

​	READ COMMITTED——每次读取数据前都生成一个ReadView：

1. 只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。

2. 在执行SELECT语句时会先生成一个`read view`，`read view`的`m_ids`列表的内容为`[99]`，`min_trx_id`为99，`max_trx_id`为99，`creator_trx_id`为0

3. 实际上通过 read view  判断行记录可见的时候， read view`的`m_ids`列表的内容为`空[]`， `min_trx_id`和 max_trx_id 都不存在，`creator_trx_id`为0；

4. 同一行记录的的 read view 为 空[]， 那么会从当前版本 trx_id=100 开始读取,  如果当前版本已提交, 那么该记录可见， 因此, 在 T2时刻 返回值为  'b' 。

   

​    REPEATABLE READ——在第一次读取数据时生成一个ReadView

1. 只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。

2. 因为当前事务的隔离级别为REPEATABLE READ，而在T1时刻在执行SELECT语句时已经生成过ReadView了，所以此时直接复用之前的ReadView，之前的ReadView的m_ids列表的内容就是[99, 100]； 

   `min_trx_id`为99，`max_trx_id`为100，`creator_trx_id`为0

3. 实际上通过 read view  判断行记录可见的时候， read view`的`m_ids`列表的内容为`[100]`， ``min_trx_id`为100，`max_trx_id`为100，`creator_trx_id`为0； 因为 trx_id=99 并不是t1.id=1这一行的版本号。  # 这样理解感觉没毛病。

4.  然后从版本链中挑选可见的记录， 读数据都是从当前版本开始读取的，最新版本 trx_id=100 处于 m_ids 列表内， 因此不可见；

5. 下一个版本的列name的内容是'a'，该版本的trx_id值为90，小于read view中的min_trx_id值100，可见； 所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为 'a' 的记录。



思考：