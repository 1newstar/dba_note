https://www.cnblogs.com/chenmh/p/5119593.html -> MySQL InnoDB存储引擎

参考思维导图的 体系结构-》存储层-》存储引擎-》InnoDB -> 内存-》 InnoDB Buffer Pool

叶老师课程的第几课？

原理：
InnoDB最重要的缓存,主要用来存储访问过的数据页面（索引页面，undo页面），
它就是一块连接的内存，通过一定的算法，可以使这块内存得到有效的管理。
（在访问一个文件页面的时候，系统都会将访问的页面载入到 Buffer Pool 中，
然后才可以访问这个页面， 此时可以读取或变更这个页面。）



对应的参数：
innodb_buffer_pool_size = 100M
innodb_buffer_pool_instances = 1

当innodb_buffer_pool_size小于1GB时候，
innodb_buffer_pool_instances被重置为1，
主要是防止有太多小的instance从而导致性能问题。


判断 InnoDB Buffer Pool 是否紧张
1. mysqladmin -uroot -p ext | grep -i innodb.*wait 
查看 Innodb_buffer_pool_wait_free 的值是否大于0， 大于0说明紧张


2. show engine innodb status\G;
Free buffers = 0 并且 Modified db pages 的值比较大， 说明 紧张



innodb_buffer_pool 紧张会造成什么问题？
当size设置偏小，会导致数据库大量直接访问磁盘
而设置过大会导致实例占用内存太多，容易发生OOM。


buffer pool 管理：
LRU机制
两个列表：Young, Old（LRU List被分为两部分，默认前5/8为young list，存储经常被使用的热点page，后3/8为old list）
热点数据（page）放在Young队列
超过 innodb_old_blocks_time 后移入 Old
Old 队列默认占比 innodb_old_blocks_pct=37


InnoDB的 Buffer Pool 可以认为很简单，就是 LRU List 和 Flush List ，
但是InnoDB对其做了很多性能上的优化，例如减少加锁范围，page hash 加速查找等，
导致具体的实现细节相对比较复杂，尤其是引入压缩页这个特性后，
有些核心代码变得晦涩难懂，需要读者细细琢磨。

LRU List:
这个是InnoDB中最重要的链表。所有新读取进来的数据页都被放在上面。 *********
链表按照最近最少使用算法排序，最近最少使用的节点被放在链表末尾，
如果Free List里面没有节点了，就会从中淘汰末尾的节点。
LRU List还包含没有被解压的压缩页，这些压缩页刚从磁盘读取出来，还没来的及被解压。
LRU List被分为两部分，默认前5/8为young list，存储经常被使用的热点page，后3/8为old list。
新读入的page默认被加在old list头，只有满足一定条件后，才被移到young list上，
主要是为了预读的数据页和全表扫描污染 buffer pool 。












MySQL 在第一次查询的时候很慢，第二次查询就比较快的原因？

查询表引擎：show variables like '%storage_engine%'，表引擎使用 InnoDB.
第一次查询也会走数据文件，
第二次直接走 buffer_pool ,从内存中读取数据，比直接查询数据文件要快.







innodb_max_dirty_pages_pct
innodb_old_blocks_pct
innodb_old_blocks_time

系统参数 innodb_max_dirty_pages_pct 和 innodb_max_dirty_pages_pct_lwm 控制脏页比例阀值








