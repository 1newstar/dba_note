
	一旦一个查询请求需要在执行过程中先 flush 掉一个脏页时，这个查询就可能要比平时慢了。
而 MySQL 中的一个机制，可能让你的查询会更慢：在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，
就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，
也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。

	
	在InnoDB中, innodb_flush_neighbors 参数就是用来控制这个行为的：	
		值为1的时候会有上述的"连坐"机制, 值为0时表示不找邻居, 自己刷自己的.

	刷邻居页在机械硬盘时代还是很有意义的, 机械硬盘的IOPS一般只有几百, 相同的逻辑操作减少随机IO意味着系统性能的大幅度提升.
	
	如果使用的是 SSD 这类 IOPS 比较高的设备的话，我就建议你把 innodb_flush_neighbors 的值设置成 0。因为这时候 IOPS 往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷脏页操作，减少 SQL 语句响应时间。	
	
	InnoDB在刷一个脏页的时候, 如果该脏页所在区(extent)也有脏页,那么一起刷盘.
	
	在 MySQL 8.0 中，innodb_flush_neighbors 参数的默认值已经是 0 了。	
	
	
开启和关闭有什么问题
在什么情景下使用:
	1. SSD盘下     关闭 innodb_flush_neighbors
	2. 机械硬盘下 开启  innodb_flush_neighbors

	
参考： 
https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_flush_neighbors
https://www.cnblogs.com/geaozhang/p/7265261.html#gongzuoyuanli    （InnoDB关键特性之刷新邻接页-异步IO）

