
1. 创建跟源表一样的新表
2. 在源码表上创建3个触发器：分别为插入、更新、删除操作的触发器, 用来做增量数据的迁移
3. 以一定chunk的大小分批量迁移数据到新表中，会对数据加共享读锁
	使用 INSERT low_priority IGNORE INTO select lock in share mode 语句分批迁移数据到新表中  -- 这个步骤没有描述好

4. 数据迁移完成，做rename表操作：把原表改为 old 表，把新表改为原表
5. 默认会把 old 表删除，drop table 操作会对数据字典加排他锁，会阻塞DML请求，直到删除表完成，才释放数据字典排他锁。
	命令添加  --no-drop-old-table 参数，就是不删除旧表。
6. 在线修改表结构完成。

-- 以上是自己的描述。

要注意的问题：
	
	1. 使用不当，会导致死锁。
		操作最后1个chunk的时候，需要持有新表的自增锁，直到最后1个chunk的数据迁移完成后，才会释放自增锁，期间会阻塞业务新插入的数据。
		自增锁冲突, 主键索引的行记录冲突导致的死锁.
		 -- 没有口述出来。
		
		
		insert into 新表 select ... from 原表 语句      增量的插入语句
		持有的锁: 新表_t_new: AUTO-INC	

														持有原表t主键索引 id=95448405 的行锁(排他X锁)
						
		在等待的锁: 原表t: primary: record lock: id=95448405

														在等待的锁: 新表_t_new: AUTO-INC
		-- 要看看怎么口述出来。					
						
	2. 默认删除旧表的操作，会对数据字典加排他锁，会阻塞DML请求，直到删除表完成，才释放数据字典排他锁。
		命令添加  --no-drop-old-table 参数，就是不删除旧表。
		
	3. 从库要设置为非双1，否则从库会有很大的延迟。