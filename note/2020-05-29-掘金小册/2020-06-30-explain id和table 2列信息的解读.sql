

1. explain各个列的描述
2. 表结构和数据初始化
3. table列
4. id列	
5. 小结
	一个SELECT关键字对应一个ID，一个表对应一行记录。


1. explain各个列的描述
	列名	     描述
	id	         在一个大的查询语句中每个SELECT关键字都对应一个唯一的id
	select_type	 SELECT关键字对应的那个查询的类型
	table	     表名
	partitions	 匹配的分区信息
	type	     针对单表的访问方法
	possible_keys	可能用到的索引
	key	         实际上使用的索引
	key_len	     实际使用到的索引长度
	ref	         当使用索引列等值查询时，与索引列进行等值匹配的对象信息
	rows	     预估的需要读取的记录条数
	filtered	 某个表经过搜索条件过滤后剩余记录条数的百分比
	Extra	     一些额外的信息



2. 表结构和数据初始化
	CREATE TABLE t1 (
		id INT NOT NULL AUTO_INCREMENT,
		key1 VARCHAR(100),
		key2 INT,
		key3 VARCHAR(100),
		common_field VARCHAR(100),
		PRIMARY KEY (id),
		KEY idx_key1 (key1),
		UNIQUE KEY idx_key2 (key2),
		KEY idx_key3 (key3)
	) Engine=InnoDB CHARSET=utf8mb4;

	CREATE TABLE t2 (
		id INT NOT NULL AUTO_INCREMENT,
		key1 VARCHAR(100),
		key2 INT,
		key3 VARCHAR(100),
		common_field VARCHAR(100),
		PRIMARY KEY (id),
		KEY idx_key1 (key1),
		UNIQUE KEY idx_key2 (key2),
		KEY idx_key3 (key3)
	) Engine=InnoDB CHARSET=utf8mb4;


	drop PROCEDURE idata();
	truncate table t1;
	truncate table t2;
	
	CREATE PROCEDURE `idata`()
	begin
	declare i int;
	set i=1;
	start transaction;
	while(i<=10000) do
	INSERT INTO t1 (key1, key2, key3, common_field) values (round(rand()*100), i, round(rand()*100), round(rand()*100));
	INSERT INTO t2 (key1, key2, key3, common_field) values (round(rand()*100), i, round(rand()*100), round(rand()*100));
	set i=i+1;
	end while;
	commit;
	end


	call idata();

	root@mysqldb 12:28:  [audit_db]> select count(*) from t1;
	+----------+
	| count(*) |
	+----------+
	|    10000 |
	+----------+
	1 row in set (0.00 sec)

	root@mysqldb 12:28:  [audit_db]> select count(*) from t2;
	+----------+
	| count(*) |
	+----------+
	|    10000 |
	+----------+
	1 row in set (0.00 sec)



3. table列

	EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名
	一个表1列
	
	root@mysqldb 14:14:  [audit_db]>  EXPLAIN SELECT * FROM t1;
	+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
	| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra |
	+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
	|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10212 |   100.00 | NULL  |
	+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
	1 row in set, 1 warning (0.00 sec)
	
	root@mysqldb 14:14:  [audit_db]> EXPLAIN SELECT * FROM t1 INNER JOIN t2;
	+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
	| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                                 |
	+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
	|  1 | SIMPLE      | t2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10210 |   100.00 | NULL                                  |
	|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10212 |   100.00 | Using join buffer (Block Nested Loop) |
	+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
	2 rows in set, 1 warning (0.00 sec)

	可以看到这个连接查询的执行计划中有两条记录，这两条记录的table列分别是t1和t2，这两条记录用来分别说明对t1表和t2表的访问方法是什么。
	
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	

4. id列
	
	查询语句中每出现一个SELECT关键字，MySQL就会为它分配一个唯一的id值。	
	一个SELECT关键字对应一个ID。
	
	--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	root@mysqldb 14:14:  [audit_db]>  EXPLAIN SELECT * FROM t1;
	+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
	| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra |
	+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
	|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10212 |   100.00 | NULL  |
	+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
	1 row in set, 1 warning (0.00 sec)
	
	
	root@mysqldb 14:17:  [audit_db]> EXPLAIN SELECT * FROM t1 INNER JOIN t2;
	+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
	| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                                 |
	+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
	|  1 | SIMPLE      | t2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10210 |   100.00 | NULL                                  |
	|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10212 |   100.00 | Using join buffer (Block Nested Loop) |
	+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
	2 rows in set, 1 warning (0.00 sec)
	
	上述连接查询中参与连接的t1和t2表分别对应一条记录，但是这两条记录对应的id值都是1。
	在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表表示驱动表，出现在后边的表表示被驱动表。
	所以从上边的EXPLAIN输出中我们可以看出，查询优化器准备让t2表作为驱动表，让t1表作为被驱动表来执行查询。
	
	--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	root@mysqldb 14:27:  [audit_db]> EXPLAIN SELECT * FROM t1 WHERE key1 IN (SELECT key1 FROM t2) OR key3 = '3';
	+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
	| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows  | filtered | Extra       |
	+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
	|  1 | PRIMARY     | t1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 10212 |   100.00 | Using where |
	|  2 | SUBQUERY    | t2    | NULL       | index | idx_key1      | idx_key1 | 403     | NULL | 10210 |   100.00 | Using index |
	+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
	2 rows in set, 1 warning (0.00 sec)
	
	对于包含子查询的查询语句来说，就可能涉及多个SELECT关键字，所以在包含子查询的查询语句的执行计划中，每个SELECT关键字都会对应一个唯一的id值;
	从输出结果中我们可以看到，t1表在外层查询中，外层查询有一个独立的SELECT关键字，所以第一条记录的id值就是1，t2表在子查询中，子查询有一个独立的SELECT关键字，所以第二条记录的id值就是2。
	
	
	root@mysqldb 16:48:  [audit_db]> show warnings;
	+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
	| Level | Code | Message                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
	+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
	| Note  | 1003 | /* select#1 */ select `audit_db`.`t1`.`id` AS `id`,`audit_db`.`t1`.`key1` AS `key1`,`audit_db`.`t1`.`key2` AS `key2`,`audit_db`.`t1`.`key3` AS `key3`,`audit_db`.`t1`.`common_field` AS `common_field` from `audit_db`.`t1` where (<in_optimizer>(`audit_db`.`t1`.`key1`,`audit_db`.`t1`.`key1` in ( <materialize> (/* select#2 */ select `audit_db`.`t2`.`key1` from `audit_db`.`t2` where 1 ), <primary_index_lookup>(`audit_db`.`t1`.`key1` in <temporary table> on <auto_key> where ((`audit_db`.`t1`.`key1` = `materialized-subquery`.`key1`))))) or (`audit_db`.`t1`.`key3` = '3')) |
	+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
	1 row in set (0.00 sec)
		
		SELECT
			`audit_db`.`t1`.`id` AS `id`,
			`audit_db`.`t1`.`key1` AS `key1`,
			`audit_db`.`t1`.`key2` AS `key2`,
			`audit_db`.`t1`.`key3` AS `key3`,
			`audit_db`.`t1`.`common_field` AS `common_field`
		FROM
			`audit_db`.`t1`
		WHERE
			(
				< in_optimizer > (
					`audit_db`.`t1`.`key1`,
					`audit_db`.`t1`.`key1` IN (
						< materialize > (
							/* select#2 */
							SELECT
								`audit_db`.`t2`.`key1`
							FROM
								`audit_db`.`t2`
							WHERE
								1
						),
						< primary_index_lookup > (
							`audit_db`.`t1`.`key1` IN < TEMPORARY TABLE > ON < auto_key >
							WHERE
								(
									(
										`audit_db`.`t1`.`key1` = `materialized-subquery`.`key1`
									)
								)
						)
					)
				)
				OR (`audit_db`.`t1`.`key3` = '3')
			) 
		
	--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	注意事项：查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询；如下：
	
	root@mysqldb 14:43:  [audit_db]> EXPLAIN SELECT * FROM t1 WHERE key1 IN (SELECT key3 FROM t2 WHERE common_field = '100');
	+----+--------------+-------------+------------+--------+---------------+------------+---------+------------------+-------+----------+-------------+
	| id | select_type  | table       | partitions | type   | possible_keys | key        | key_len | ref              | rows  | filtered | Extra       |
	+----+--------------+-------------+------------+--------+---------------+------------+---------+------------------+-------+----------+-------------+
	|  1 | SIMPLE       | t1          | NULL       | ALL    | idx_key1      | NULL       | NULL    | NULL             | 10212 |   100.00 | Using where |
	|  1 | SIMPLE       | <subquery2> | NULL       | eq_ref | <auto_key>    | <auto_key> | 403     | audit_db.t1.key1 |     1 |   100.00 | NULL        |
	|  2 | MATERIALIZED | t2          | NULL       | ALL    | idx_key3      | NULL       | NULL    | NULL             | 10210 |    10.00 | Using where |
	+----+--------------+-------------+------------+--------+---------------+------------+---------+------------------+-------+----------+-------------+
	3 rows in set, 1 warning (0.00 sec)
	
	root@mysqldb 14:43:  [audit_db]> show warnings;
	+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
	| Level | Code | Message                                                                                                                                                                                                                                                                                                                                                      |
	+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
	| Note  | 1003 | /* select#1 */ select `audit_db`.`t1`.`id` AS `id`,`audit_db`.`t1`.`key1` AS `key1`,`audit_db`.`t1`.`key2` AS `key2`,`audit_db`.`t1`.`key3` AS `key3`,`audit_db`.`t1`.`common_field` AS `common_field` from `audit_db`.`t1` semi join (`audit_db`.`t2`) where ((`<subquery2>`.`key3` = `audit_db`.`t1`.`key1`) and (`audit_db`.`t2`.`common_field` = '100')) |
	+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
	1 row in set (0.00 sec)
	
		SELECT
			`audit_db`.`t1`.`id` AS `id`,
			`audit_db`.`t1`.`key1` AS `key1`,
			`audit_db`.`t1`.`key2` AS `key2`,
			`audit_db`.`t1`.`key3` AS `key3`,
			`audit_db`.`t1`.`common_field` AS `common_field`
		FROM
			`audit_db`.`t1` semi JOIN (`audit_db`.`t2`)
		WHERE
		(
			(
				`<subquery2>`.`key3` = `audit_db`.`t1`.`key1`
			)
			AND (
				`audit_db`.`t2`.`common_field` = '100'
			)
		)
	
	Semi join: 
		使用哈希连接执行，将会利用子查询部分作为构建表，通过连接属性计算哈希值，然后使用外部查询的连接属性的哈希值进行匹配，输出匹配的结果。
		这里利用子查询构建 subquery2 表
		
	----------------------------------------------------------------------------------------------------------------------------
	
	root@mysqldb 14:45:  [audit_db]> EXPLAIN SELECT * FROM t1  UNION SELECT * FROM t2;
	+----+--------------+------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+
	| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra           |
	+----+--------------+------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+
	|  1 | PRIMARY      | t1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10212 |   100.00 | NULL            |
	|  2 | UNION        | t2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10210 |   100.00 | NULL            |
	| NULL | UNION RESULT | <union1,2> | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  NULL |     NULL | Using temporary |
	+----+--------------+------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+
	3 rows in set, 1 warning (0.08 sec)

	UNION子句：它会把多个查询的结果集合并起来放在临时表中并对临时表中的结果集中的记录进行去重。
	
	UNION子句是为了把id为1的查询和id为2的查询的结果集合并起来并去重，所以在内部创建了一个名为<union1, 2>的临时表（就是执行计划第三条记录的table列的名称），id为NULL表明这个临时表是为了合并两个查询的结果集而创建的。
	
	<union1,2>：表示把t1和t2表的结果集合并起来。
	 
	UNION ALL 就不需要为最终的结果集进行去重，它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。
	
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
