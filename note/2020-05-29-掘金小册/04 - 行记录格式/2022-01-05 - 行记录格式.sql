

初始化表结构和数据
	
	mysql> USE xiaohaizi;
	Database changed

	mysql> CREATE TABLE record_format_demo (
		->     c1 VARCHAR(10),
		->     c2 VARCHAR(10) NOT NULL,
		->     c3 CHAR(10),
		->     c4 VARCHAR(10)
		-> ) CHARSET=ascii ROW_FORMAT=COMPACT;
	Query OK, 0 rows affected (0.03 sec)



	mysql> INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES('aaaa', 'bbb', 'cc', 'd'), ('eeee', 'fff', NULL, NULL);
	Query OK, 2 rows affected (0.02 sec)
	Records: 2  Duplicates: 0  Warnings: 0


	mysql> SELECT * FROM record_format_demo;
	+------+-----+------+------+
	| c1   | c2  | c3   | c4   |
	+------+-----+------+------+
	| aaaa | bbb | cc   | d    |
	| eeee | fff | NULL | NULL |
	+------+-----+------+------+
	2 rows in set (0.00 sec)




COMPACT行格式
	
	1. 记录的额外信息和记录的真实数据
		
		记录的额外信息：
            变长字段长度列表
            NULL值列表
            记录头信息
			
        记录的真实数据：
			主键ID
            事务ID
            回滚指针
            各个列的值
			
			
	2. 变长字段长度列表
		
		变长字段的类型
			比如 VARCHAR(M)、VARBINARY(M)、各种TEXT类型，各种BLOB类型
	
	
		这些变长字段占用的存储空间分为两部分：

			真正的数据内容
			占用的字节数(也就是变长字段长度列表)
			
		在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放(很重要)
		
		举例：
			record_format_demo表中的第一条记录
				因为record_format_demo表的c1、c2、c4列都是VARCHAR(10)类型的，也就是变长的数据类型，所以这三个列的值的长度都需要保存在记录开头处
				因为record_format_demo表中的各个列都使用的是ascii字符集，所以每个字符只需要1个字节来进行编码，来看一下第一条记录各变长字段内容的长度：
			
					列名	存储内容	内容长度（十进制表示）	内容长度（ 十六进制 表示）
					c1		'aaaa'		4						0x04
					c2		'bbb'		3						0x03
					c4		'd'			1						0x01
			
				
				最后变长字段长度列表的字节串用 十六进制 表示的效果就是（各个字节之间实际上没有空格，用空格隔开只是方便理解）：01 03 04 
		
		
			record_format_demo表中的第二条记录

					列名	存储内容	内容长度（十进制表示）	内容长度（ 十六进制 表示）
					c1		'eeee'		4						0x04
					c2		'fff'		3						0x03
				
		
				最后变长字段长度列表的字节串用 十六进制 表示的效果就是（各个字节之间实际上没有空格，用空格隔开只是方便理解）：03 04 

			
			
		用1个还是2个字节来表示真实数据占用的字节数的公式 
		
			先声明一下W、M和L的意思：

				W: 假设某个字符集中表示一个字符最多需要使用的字节数为W，也就是使用SHOW CHARSET语句的结果中的Maxlen列，比方说utf8字符集中的W就是3，gbk字符集中的W就是2，ascii字符集中的W就是1。

				M: 对于变长类型VARCHAR(M)来说，这种类型表示能存储最多M个字符（注意是字符不是字节），所以这个类型能表示的字符串最多占用的字节数就是M×W。

				L: 假设它实际存储的字符串占用的字节数是L。
			
			M×W <= 255，那么使用1个字节来表示真正字符串占用的字节数：

				也就是说InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数不大于255时，可以认为只使用1个字节来表示真正字符串占用的字节数。
		
				
			M×W > 255，则分为两种情况：
				
				如果L <= 127，则用1个字节来表示真正字符串占用的字节数。

				如果L > 127，则用2个字节来表示真正字符串占用的字节数。

			
			总结：
				如果该可变字段允许存储的最大字节数（M×W）超过255字节并且真实存储的字节数（L）超过127字节，则使用2个字节，否则使用1个字节。
				
				-- 理解了。
		
		
		第1行记录变长字段列表共需要3个字节：
		
			c1列存储的值为'aaaa'，占用的字节数为4
			c2列存储的值为'bbb'，占用的字节数为3
			c4列存储的值为'd'，占用的字节数为1
			
			数字4可以用1个字节表示，3也可以用1个字节表示，3也可以用1个字节表示, 所以整个变长字段长度列表共需3个字节。
			
			
		第2行记录变长字段列表共需要2个字节：
		
			c1列存储的值为'eeee'，占用的字节数为4
			c2列存储的值为'fff'，占用的字节数为3
			数字4可以用1个字节表示，3也可以用1个字节表示，所以整个变长字段长度列表共需2个字节。
			
			
				
	3. NULL值列表
		
		字段值为 NULL 不占列数据任何空间，即 NULL 除了占有 NULL 标志位(bit)，实际存储不占用任何空间。
		1个NULL值占用1个bit
		
		第1行记录没有NULL值，所以实际存储不占用任何空间。
		第2行记录有2个NULL值，占用2个bit。
		
		
		
	4. 记录头信息
	
		用于描述记录的记录头信息，它是由固定的5个字节组成。5个字节也就是40个二进制位，不同的位代表不同的意思
		固定占 5 bytes, 包含下一条记录的位置，该行记录总长度，记录类型，是否被删除，对应的 slot 信息等	
		
			二进制位代表的详细信息如下表：

				名称			大小（单位：bit）	描述
				预留位1			1					没有使用
				预留位2			1					没有使用
				delete_mask		1					标记该记录是否被删除
				min_rec_mask	1					B+树的每层非叶子节点中的最小记录都会添加该标记
				n_owned			4					表示当前记录拥有的记录数
				heap_no			13					表示当前记录在记录堆的位置信息
				record_type		3					表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录
				next_record		16					表示下一条记录的相对位置

					


			
		
	
		
		
		
	
				