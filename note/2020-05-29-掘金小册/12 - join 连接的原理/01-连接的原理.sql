
1. 连接原理
	1.1 连接的本质 
	1.2 连接过程简介
	
2. 内连接和外连接
	2.1 表结构和数据初始化
	2.2 左(外)连接的语法
	2.3 右(外)连接的语法
	2.4 内连接的语法
	2.5 小结
	2.6 内连接/左连接/右连接的结果集对比 


3. 连接的原理
	3.1 嵌套循环连接（Nested-Loop Join）
	3.2 基于块的嵌套循环连接（Block Nested-Loop Join）	



1. 连接原理
1.1 连接的本质 

	CREATE TABLE t1 (m1 int, n1 char(1));

	CREATE TABLE t2 (m2 int, n2 char(1));

	INSERT INTO t1 VALUES(1, 'a'), (2, 'b'), (3, 'c');

	INSERT INTO t2 VALUES(2, 'b'), (3, 'c'), (4, 'd');
	
	两个表的连接查询
		mysql>select * from t1,t2;
		+------+------+------+------+
		| m1   | n1   | m2   | n2   |
		+------+------+------+------+
		|    1 | a    |    2 | b    |
		|    2 | b    |    2 | b    |
		|    3 | c    |    2 | b    |
		|    1 | a    |    3 | c    |
		|    2 | b    |    3 | c    |
		|    3 | c    |    3 | c    |
		|    1 | a    |    4 | d    |
		|    2 | b    |    4 | d    |
		|    3 | c    |    4 | d    |
		+------+------+------+------+
		9 rows in set (0.00 sec)
	
	连接的本质: 就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。
	连接查询:   这个过程看起来就是把t1表的记录和t2的记录连起来组成新的更大的记录，所以这个查询过程称之为 连接查询 。
	
	笛卡尔积:   
		两个表或者两个表以上进行连接查询得到的结果集, 称为 笛卡尔积.
		因为表t1中有3条记录，表t2中也有3条记录，所以这两个表连接之后的笛卡尔积就有3×3=9行记录。
		
		假设没有任何限制条件的话, 比方说3个100行记录的表连接起来产生的笛卡尔积就有100×100×100=1000000行数据！
		
	在MySQL中，连接查询的语法也很随意，只要在FROM语句后边跟多个表名就好了.
	

1.2 连接过程简介

	在连接查询中的过滤条件可以分成两种：

		1. 涉及单表的条件
			只涉及单表的过滤条件我们称为 搜索条件
			比如t1.m1 > 1是只针对t1表的过滤条件，t2.n2 < 'd'是只针对t2表的过滤条件。
			
		2. 涉及两表的条件
			比如 t1.m1 = t2.m2、t1.n1 > t2.n2 等
			
		
	举例说明 
		SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
		在这个查询中我们指明了这三个过滤条件：
			t1.m1 > 1

			t1.m1 = t2.m2

			t2.n2 < 'd'
			
		那么这个连接查询的大致执行过程如下：
		
			1. 首先确定第一个需要查询的表，这个表称之为驱动表
			
				只需要选取代价最小的那种访问方法去执行单表查询语句就好了(就是说从const、ref、ref_or_null、range、index、all这些执行方法中选取代价最小的去执行查询)

				此处假设使用t1作为驱动表，那么就需要到t1表中找满足t1.m1 > 1的记录，因为表中的数据太少，我们也没在表上建立二级索引，所以此处查询t1表的访问方法就设定为all吧，也就是采用全表扫描的方式执行单表查询。
				
				此时, t1表中符合t1.m1 > 1的记录有两条:
				
					mysql>select * from t1 where m1>1;
					+------+------+
					| m1   | n1   |
					+------+------+
					|    2 | b    |
					|    3 | c    |
					+------+------+
					2 rows in set (0.00 sec)	
					
			2. 到被驱动表匹配记录
			
				针对上一步骤中从驱动表产生的结果集中的每一条记录，分别需要到t2表中查找匹配的记录，所谓匹配的记录，指的是符合过滤条件的记录。
				
				因为是根据t1表中的记录去找t2表中的记录，所以t2表也可以被称之为被驱动表。
				
				上一步骤从驱动表中得到了2条记录，所以需要查询2次t2表。
				
				此时涉及两个表的列的过滤条件t1.m1 = t2.m2就派上用场了：
				
					2.1 当t1.m1 = 2时，过滤条件t1.m1 = t2.m2就相当于t2.m2 = 2，所以此时t2表相当于有了t2.m2 = 2、t2.n2 < 'd'这两个过滤条件，然后到t2表中执行单表查询。
						
						mysql>select * from t2 where t2.m2 = 2 and t2.n2 < 'd';
						+------+------+
						| m2   | n2   |
						+------+------+
						|    2 | b    |
						+------+------+
						1 row in set (0.00 sec)

						
					2.2 当t1.m1 = 3时，过滤条件t1.m1 = t2.m2就相当于t2.m2 = 3，所以此时t2表相当于有了t2.m2 = 3、t2.n2 < 'd'这两个过滤条件，然后到t2表中执行单表查询。
					
						mysql>select * from t2 where t2.m2 = 3 and t2.n2 < 'd';
						+------+------+
						| m2   | n2   |
						+------+------+
						|    3 | c    |
						+------+------+
						1 row in set (0.00 sec)
						
				也就是说整个连接查询最后的结果只有两条符合过滤条件的记录：
				
					mysql>SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
					+------+------+------+------+
					| m1   | n1   | m2   | n2   |
					+------+------+------+------+
					|    2 | b    |    2 | b    |
					|    3 | c    |    3 | c    |
					+------+------+------+------+
					2 rows in set (0.01 sec)	
					
		从上边两个步骤可以看出来，我们上边唠叨的这个两表连接查询共需要查询1次t1表，2次t2表。当然这是在特定的过滤条件下的结果	
		如果我们把t1.m1 > 1这个条件去掉，那么从t1表中查出的记录就有3条，就需要查询3次t2表了。
		也就是说在两表连接查询中，驱动表只需要访问一次，被驱动表可能被访问多次。
		
	
2. 内连接和外连接

2.1 表结构和数据初始化
	
	-- 学生信息表
	CREATE TABLE student (
		number INT NOT NULL AUTO_INCREMENT COMMENT '学号',
		name VARCHAR(5) COMMENT '姓名',
		major VARCHAR(30) COMMENT '专业',
		PRIMARY KEY (number)
	) Engine=InnoDB CHARSET=utf8 COMMENT '学生信息表';
	
	-- 学生成绩表
	CREATE TABLE score (
		number INT COMMENT '学号',
		subject VARCHAR(30) COMMENT '科目',
		score TINYINT COMMENT '成绩',
		PRIMARY KEY (number, subject)
	) Engine=InnoDB CHARSET=utf8 COMMENT '学生成绩表';
		
	INSERT INTO `db3`.`student` (`number`, `name`, `major`) VALUES ('20180101', '杜子腾', '软件学院 ');
	INSERT INTO `db3`.`student` (`number`, `name`, `major`) VALUES ('20180102', '范统', '计算机科学与工程');
	INSERT INTO `db3`.`student` (`number`, `name`, `major`) VALUES ('20180103', '史珍香', '计算机科学与工程');
				
	INSERT INTO `db3`.`score` (`number`, `subject`, `score`) VALUES ('20180101', '母猪的产后护理', '80');
	INSERT INTO `db3`.`score` (`number`, `subject`, `score`) VALUES ('20180101', '论萨达姆的战争准备', '90');
	INSERT INTO `db3`.`score` (`number`, `subject`, `score`) VALUES ('20180102', '论萨达姆的战争准备', '80');
	INSERT INTO `db3`.`score` (`number`, `subject`, `score`) VALUES ('20180102', '母猪的产后护理', '90');

	mysql>select * from student;
	+----------+-----------+--------------------------+
	| number   | name      | major                    |
	+----------+-----------+--------------------------+
	| 20180101 | 杜子腾    | 软件学院                 |
	| 20180102 | 范统      | 计算机科学与工程         |
	| 20180103 | 史珍香    | 计算机科学与工程         |
	+----------+-----------+--------------------------+
	3 rows in set (0.00 sec)
	
	mysql>select * from score;
	+----------+-----------------------------+-------+
	| number   | subject                     | score |
	+----------+-----------------------------+-------+
	| 20180101 | 母猪的产后护理              |    80 |
	| 20180101 | 论萨达姆的战争准备          |    90 |
	| 20180102 | 母猪的产后护理              |    90 |
	| 20180102 | 论萨达姆的战争准备          |    80 |
	+----------+-----------------------------+-------+
	4 rows in set (0.00 sec)
	
	把每个学生的考试成绩都查询出来
	
		想把每个学生的考试成绩都查询出来就需要进行两表连接了(因为score中没有姓名信息，所以不能单纯只查询score表)。
		连接过程就是从student表中取出记录，在score表中查找number相同的成绩记录，所以过滤条件就是 student.number = socre.number，整个查询语句就是这样：
		
		-- 使用的是内连接方式
		mysql>SELECT s1.number, s1.name, s2.subject, s2.score FROM student AS s1, score AS s2 WHERE s1.number = s2.number;
		+----------+-----------+-----------------------------+-------+
		| number   | name      | subject                     | score |
		+----------+-----------+-----------------------------+-------+
		| 20180101 | 杜子腾    | 母猪的产后护理              |    80 |
		| 20180101 | 杜子腾    | 论萨达姆的战争准备          |    90 |
		| 20180102 | 范统      | 母猪的产后护理              |    90 |
		| 20180102 | 范统      | 论萨达姆的战争准备          |    80 |
		+----------+-----------+-----------------------------+-------+
		4 rows in set (0.01 sec)
		
		史珍香同学，也就是学号为 20180103 的同学因为某些原因没有参加考试，所以在score表中没有对应的成绩记录。
		首先, 驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。为了解决这个问题，就有了内连接和外连接的概念：
		
			1. 对于内连接的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的内连接。
			
			2. 对于外连接的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。
			
			3. 在MySQL中，根据选取驱动表的不同，外连接仍然可以细分为2种：

				左外连接: 选取左侧的表为驱动表。
	
				右外连接: 选取右侧的表为驱动表。
				
		然后, 放在不同地方的过滤条件是有不同语义的：
		
			1. WHERE子句中的过滤条件

				WHERE子句中的过滤条件就是我们平时见的那种，不论是内连接还是外连接，凡是不符合WHERE子句中的过滤条件的记录都不会被加入最后的结果集。
			
			2. ON子句中的过滤条件
			
				对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充。
				
			
	这个ON子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记录加入结果集这个场景下提出的，
	所以如果把ON子句放到内连接中，MySQL会把它和WHERE子句一样对待，也就是说：
		内连接中的WHERE子句和ON子句是等价的。
	
	一般情况下，我们都把只涉及单表的过滤条件放到WHERE子句中，把涉及两表的过滤条件都放到ON子句中，我们也一般把放到ON子句中的过滤条件也称之为连接条件。
	

2.2 左(外)连接的语法

	左(外)连接的语法还是挺简单的，比如我们要把t1表和t2表进行左外连接查询可以这么写：
		SELECT * FROM t1 LEFT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];
	
	其中中括号里的OUTER单词是可以省略的。	
	
	对于LEFT JOIN类型的连接来说，我们把放在左边的表称之为外表或者驱动表，右边的表称之为内表或者被驱动表。
	
	所以上述例子中t1就是外表或者驱动表，t2就是内表或者被驱动表。
	
	需要注意的是，对于左（外）连接和右（外）连接来说，必须使用ON子句来指出连接条件。
	
			
	把所有的学生的成绩信息都查询出来，即使是缺考的考生也应该被放到结果集中：		
	
		SELECT s1.number, s1.name, s2.subject, s2.score FROM student AS s1, score AS s2 WHERE s1.number = s2.number;
	
		mysql>SELECT s1.number, s1.name, s2.subject, s2.score FROM student as s1 left join score as s2 on s1.number = s2.number;
		+----------+-----------+-----------------------------+-------+
		| number   | name      | subject                     | score |
		+----------+-----------+-----------------------------+-------+
		| 20180101 | 杜子腾    | 母猪的产后护理              |    80 |
		| 20180101 | 杜子腾    | 论萨达姆的战争准备          |    90 |
		| 20180102 | 范统      | 母猪的产后护理              |    90 |
		| 20180102 | 范统      | 论萨达姆的战争准备          |    80 |
		| 20180103 | 史珍香    | NULL                        |  NULL |
		+----------+-----------+-----------------------------+-------+
		5 rows in set (0.00 sec)
		
	从结果集中可以看出来，虽然史珍香并没有对应的成绩记录，但是由于采用的是连接类型为左（外）连接，所以仍然把她放到了结果集中，只不过在对应的成绩记录的各列使用NULL值填充而已。

2.3 右(外)连接的语法

	右（外）连接和左（外）连接的原理是一样一样的，语法也只是把LEFT换成RIGHT而已：

	SELECT * FROM t1 RIGHT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];
	
	只不过驱动表是右边的表，被驱动表是左边的表，具体就不唠叨了。


2.4 内连接的语法

	内连接和外连接的根本区别就是在驱动表中的记录不符合ON子句中的连接条件时不会把该记录加入到最后的结果集
	
	SELECT * FROM t1 [INNER | CROSS] JOIN t2 [ON 连接条件] [WHERE 普通过滤条件];

	也就是说在MySQL中，下边这几种内连接的写法都是等价的：

		SELECT * FROM t1 JOIN t2;

		SELECT * FROM t1 INNER JOIN t2;

		SELECT * FROM t1 CROSS JOIN t2;
		
	上边的这些写法和直接把需要连接的表名放到FROM语句之后，用逗号,分隔开的写法是等价的：

		SELECT * FROM t1, t2;
		
	由于在内连接中ON子句和WHERE子句是等价的，所以内连接中不要求强制写明ON子句。
	
	
2.5 小结

	连接的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。不论哪个表作为驱动表，两表连接产生的笛卡尔积肯定是一样的。
	
	对于内连接来说，由于凡是不符合ON子句或WHERE子句中的条件的记录都会被过滤掉，其实也就相当于从两表连接的笛卡尔积中把不符合过滤条件的记录给踢出去，所以对于内连接来说，驱动表和被驱动表是可以互换的，并不会影响最后的查询结果。
	
	对于外连接来说，由于驱动表中的记录即使在被驱动表中找不到符合ON子句条件的记录时也要将其加入到结果集，所以此时驱动表和被驱动表的关系就很重要了，也就是说左外连接和右外连接的驱动表和被驱动表不能轻易互换。

2.6 内连接/左连接/右连接的结果集对比 

	mysql> SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2;
	+------+------+------+------+
	| m1   | n1   | m2   | n2   |
	+------+------+------+------+
	|    2 | b    |    2 | b    |
	|    3 | c    |    3 | c    |
	+------+------+------+------+
	2 rows in set (0.00 sec)

	mysql> SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2;
	+------+------+------+------+
	| m1   | n1   | m2   | n2   |
	+------+------+------+------+
	|    2 | b    |    2 | b    |
	|    3 | c    |    3 | c    |
	|    1 | a    | NULL | NULL |
	+------+------+------+------+
	3 rows in set (0.00 sec)

	
	mysql>SELECT * FROM t1 RIGHT JOIN t2 ON t1.m1 = t2.m2;
	+------+------+------+------+
	| m1   | n1   | m2   | n2   |
	+------+------+------+------+
	|    2 | b    |    2 | b    |
	|    3 | c    |    3 | c    |
	| NULL | NULL |    4 | d    |
	+------+------+------+------+
	3 rows in set (0.00 sec)
	
	
3. 连接的原理

3.1 嵌套循环连接（Nested-Loop Join）

	对于两表连接来说，驱动表只会被访问一遍，但被驱动表却要被访问到好多遍，具体访问几遍取决于对驱动表执行单表查询后的结果集中的记录条数
	对于内连接来说，选取哪个表为驱动表都没关系
	外连接的驱动表是固定的，也就是说左（外）连接的驱动表就是左边的那个表，右（外）连接的驱动表就是右边的那个表。
	
	SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2;
	
		步骤1：选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询。
		
		步骤2：对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录。


	如果有3个表进行连接的话，那么步骤2中得到的结果集就像是新的驱动表，然后第三个表就成为了被驱动表，重复上边过程，也就是步骤2中得到的结果集中的每一条记录都需要到t3表中找一找有没有匹配的记录，用伪代码表示一下这个过程就是这样：

		for each row in t1 {   #此处表示遍历满足对t1单表查询结果集中的每一条记录
			
			for each row in t2 {   #此处表示对于某条t1表的记录来说，遍历满足对t2单表查询结果集中的每一条记录
			
				for each row in t3 {   #此处表示对于某条t1和t2表的记录组合来说，对t3表进行单表查询
					if row satisfies join conditions, send to client
				}
			}
		}
	这个过程就像是一个嵌套的循环，所以这种驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为嵌套循环连接（Nested-Loop Join），这是最简单，也是最笨拙的一种连接查询算法。

3.2 基于块的嵌套循环连接（Block Nested-Loop Join）




	select STRAIGHT_JOIN



使用内连接，不改变驱动表的顺序。


