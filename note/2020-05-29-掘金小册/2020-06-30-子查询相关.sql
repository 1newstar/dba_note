
1. 子查询语法
2. IN子查询优化
	2.1 物化表的提出
	2.2 物化表转连接
	2.3 将子查询转换为semi-join
	2.4 semi-join的适用条件
	2.5 不适用于semi-join的情况
	2.6 如何优化不能转为semi-join查询的子查询
	2.7 小结
	
	
1. 子查询语法

	FROM子句
		SELECT m, n FROM (SELECT m2 + 1 AS m, n2 AS n FROM t2 WHERE m2 > 2) AS t;

		这个例子中的子查询是：(SELECT m2 + 1 AS m, n2 AS n FROM t2 WHERE m2 > 2)，很特别的地方是它出现在了FROM子句中。
		FROM子句里边儿不是存放我们要查询的表的名称么，这里放进来一个子查询是个什么鬼？
		其实这里我们可以把子查询的查询结果当作是一个表，子查询后边的 AS t 表明这个子查询的结果就相当于一个名称为t的表，这个名叫t的表的列就是子查询结果中的列
		比如例子中表t就有两个列：m列和n列。
		这个放在FROM子句中的子查询本质上相当于一个表，但又和我们平常使用的表有点儿不一样，设计MySQL的大叔把这种由子查询结果集组成的表称之为派生表。
	

2. IN子查询优化

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2.0 in子查询转semi join的案例
	root@mysqldb 09:51:  [audit_db]> desc SELECT * FROM t1  WHERE key1 IN (SELECT common_field FROM t2 WHERE key3 = '100');
	+----+--------------+-------------+------------+------+---------------+----------+---------+--------------------------+------+----------+-------------+
	| id | select_type  | table       | partitions | type | possible_keys | key      | key_len | ref                      | rows | filtered | Extra       |
	+----+--------------+-------------+------------+------+---------------+----------+---------+--------------------------+------+----------+-------------+
	|  1 | SIMPLE       | <subquery2> | NULL       | ALL  | NULL          | NULL     | NULL    | NULL                     | NULL |   100.00 | Using where |
	|  1 | SIMPLE       | t1          | NULL       | ref  | idx_key1      | idx_key1 | 403     | <subquery2>.common_field |  101 |   100.00 | NULL        |
	|  2 | MATERIALIZED | t2          | NULL       | ref  | idx_key3      | idx_key3 | 403     | const                    |   40 |   100.00 | NULL        |
	+----+--------------+-------------+------------+------+---------------+----------+---------+--------------------------+------+----------+-------------+
	3 rows in set, 1 warning (0.00 sec)


	root@mysqldb 09:51:  [audit_db]> show warnings;
	+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
	| Level | Code | Message                                                                                                                                                                                                                                                                                                                                                      |
	+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
	| Note  | 1003 | /* select#1 */ select `audit_db`.`t1`.`id` AS `id`,`audit_db`.`t1`.`key1` AS `key1`,`audit_db`.`t1`.`key2` AS `key2`,`audit_db`.`t1`.`key3` AS `key3`,`audit_db`.`t1`.`common_field` AS `common_field` from `audit_db`.`t1` semi join (`audit_db`.`t2`) where ((`audit_db`.`t1`.`key1` = `<subquery2>`.`common_field`) and (`audit_db`.`t2`.`key3` = '100')) |
	+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
	1 row in set (0.00 sec)

	SELECT
		`audit_db`.`t1`.`id` AS `id`,
		`audit_db`.`t1`.`key1` AS `key1`,
		`audit_db`.`t1`.`key2` AS `key2`,
		`audit_db`.`t1`.`key3` AS `key3`,
		`audit_db`.`t1`.`common_field` AS `common_field`
	FROM
		`audit_db`.`t1` semi
	JOIN (`audit_db`.`t2`)
	WHERE
		(
			(
				`audit_db`.`t1`.`key1` = `<subquery2>`.`common_field`
			)
			AND (
				`audit_db`.`t2`.`key3` = '100'
			)
		)
	
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	
2.1 物化表的提出
		
	MATERIALIZED：表示物化表，物化表用于存储子查询结果集的列
	
	如果单独执行子查询后的结果集太多的话，就会导致这些问题：
		
		结果集太多，可能内存中都放不下
		
		对于外层查询来说，如果子查询的结果集太多，那就意味着IN子句中的参数特别多，这就导致：
			1. 无法有效的使用索引，只能对外层查询进行全表扫描。

			2. 在对外层查询执行全表扫描时，由于IN子句中的参数太多，这会导致检测一条记录是否符合和IN子句中的参数匹配花费的时间太长。

				比如说IN子句中的参数只有两个：SELECT * FROM tbl_name WHERE column IN (a, b);
				这样相当于需要对tbl_name表中的每条记录判断一下它的column列是否符合column = a OR column = b。在IN子句中的参数比较少时这并不是什么问题
				
				如果IN子句中的参数比较多时，比如这样：
					SELECT * FROM tbl_name WHERE column IN (a, b, c ..., ...);
					那么这样每条记录需要判断一下它的column列是否符合column = a OR column = b OR column = c OR ...，这样性能耗费可就多了。
					
	
	因此，想出了一个优化办法：不直接将不相关子查询的结果集当作外层查询的参数，而是将该结果集写入一个临时表里。
	
	写入临时表的过程是这样的：

		1. 该临时表的列就是子查询结果集中的列。

		2. 写入临时表的记录会被去重。

		3. 我们说IN语句是判断某个操作数在不在某个集合中，集合中的值重不重复对整个IN语句的结果并没有啥子关系，所以我们在将结果集写入临时表时对记录进行去重可以让临时表变得更小，更省地方～
		
		4. 一般情况下子查询结果集不会大的离谱，所以会为它建立基于内存的使用Memory存储引擎的临时表，而且会为该表建立哈希索引。

		5. 如果子查询的结果集非常大，超过了系统变量 tmp_table_size 或者 max_heap_table_size ，临时表会转而使用基于磁盘的存储引擎来保存结果集中的记录，索引类型也对应转变为B+树索引。
		
	把子查询结果集中的记录保存到临时表的过程称之为物化（英文名：Materialize）
	
	为了方便起见，我们就把那个存储子查询结果集的临时表称之为物化表。
	
	正因为物化表中的记录都建立了索引（基于内存的物化表有哈希索引，基于磁盘的有B+树索引），通过索引执行IN语句判断某个操作数在不在子查询结果集中变得非常快，从而提升了子查询语句的性能。
	
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	

2.2 物化表转连接

	root@mysqldb 09:51:  [audit_db]> desc SELECT * FROM t1  WHERE key1 IN (SELECT common_field FROM t2 WHERE key3 = '100');
	+----+--------------+-------------+------------+------+---------------+----------+---------+--------------------------+------+----------+-------------+
	| id | select_type  | table       | partitions | type | possible_keys | key      | key_len | ref                      | rows | filtered | Extra       |
	+----+--------------+-------------+------------+------+---------------+----------+---------+--------------------------+------+----------+-------------+
	|  1 | SIMPLE       | <subquery2> | NULL       | ALL  | NULL          | NULL     | NULL    | NULL                     | NULL |   100.00 | Using where |
	|  1 | SIMPLE       | t1          | NULL       | ref  | idx_key1      | idx_key1 | 403     | <subquery2>.common_field |  101 |   100.00 | NULL        |
	|  2 | MATERIALIZED | t2          | NULL       | ref  | idx_key3      | idx_key3 | 403     | const                    |   40 |   100.00 | NULL        |
	+----+--------------+-------------+------------+------+---------------+----------+---------+--------------------------+------+----------+-------------+
	3 rows in set, 1 warning (0.00 sec)
	
	当我们把子查询进行物化之后，假设子查询物化表的名称为 materialized_table ，该物化表存储的子查询结果集的列为 m_val ，那么这个查询其实可以从下边两种角度来看待：
		
		1. 从表t1的角度来看待，整个查询的意思其实是：
			对于t1表中的每条记录来说，如果该记录的key1列的值在子查询对应的物化表中，则该记录会被加入最终的结果集。画个图表示一下就是这样：
			
			t1.key1 = t2.common_field
			
		2. 从子查询物化表的角度来看待，整个查询的意思其实是：
			对于子查询物化表的每个值来说，如果能在t1表中找到对应的key1列的值与该值相等的记录，那么就把这些记录加入到最终的结果集。画个图表示一下就是这样：
			
			t2.common_field = t1.key1
			
	
	也就是说其实上边的查询就相当于表t1和子查询物化表materialized_table进行内连接：

		SELECT t1.* FROM t1 INNER JOIN materialized_table ON key1 = m_val;
	
	转化成内连接之后就有意思了，查询优化器可以评估不同连接顺序需要的成本是多少，选取成本最低的那种查询方式执行查询。
	
	我们分析一下上述查询中使用外层查询的表t1和物化表materialized_table进行内连接的成本都是由哪几部分组成的：
	

	如果使用t1表作为驱动表的话，总查询成本由下边几个部分组成：
		
		物化子查询时需要的成本

		扫描t1表时的成本

		t1表中的记录数量 × 通过m_val = xxx对materialized_table表进行单表访问的成本（我们前边说过物化表中的记录是不重复的，并且为物化表中的列建立了索引，所以这个步骤显然是非常快的）。

	如果使用materialized_table表作为驱动表的话，总查询成本由下边几个部分组成：
		
		物化子查询时需要的成本

		扫描物化表时的成本

		物化表中的记录数量 × 通过key1 = xxx对t1表进行单表访问的成本（非常庆幸 key1 列上建立了索引，所以这个步骤是非常快的）。

	
	MySQL查询优化器会通过运算来选择上述成本更低的方案来执行查询。


2.3 将子查询转换为semi-join

	虽然将子查询进行物化之后再执行查询都会有建立临时表的成本，但是不管怎么说，我们见识到了将子查询转换为连接的强大作用
	设计MySQL的大叔继续开脑洞：能不能不进行物化操作直接把子查询转换为连接呢？
	让我们重新审视一下上边的查询语句：

		root@mysqldb 09:51:  [audit_db]> desc SELECT * FROM t1  WHERE key1 IN (SELECT common_field FROM t2 WHERE key3 = '100');
		+----+--------------+-------------+------------+------+---------------+----------+---------+--------------------------+------+----------+-------------+
		| id | select_type  | table       | partitions | type | possible_keys | key      | key_len | ref                      | rows | filtered | Extra       |
		+----+--------------+-------------+------------+------+---------------+----------+---------+--------------------------+------+----------+-------------+
		|  1 | SIMPLE       | <subquery2> | NULL       | ALL  | NULL          | NULL     | NULL    | NULL                     | NULL |   100.00 | Using where |
		|  1 | SIMPLE       | t1          | NULL       | ref  | idx_key1      | idx_key1 | 403     | <subquery2>.common_field |  101 |   100.00 | NULL        |
		|  2 | MATERIALIZED | t2          | NULL       | ref  | idx_key3      | idx_key3 | 403     | const                    |   40 |   100.00 | NULL        |
		+----+--------------+-------------+------------+------+---------------+----------+---------+--------------------------+------+----------+-------------+
		3 rows in set, 1 warning (0.00 sec)


		root@mysqldb 09:51:  [audit_db]> show warnings;
		+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
		| Level | Code | Message                                                                                                                                                                                                                                                                                                                                                      |
		+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
		| Note  | 1003 | /* select#1 */ select `audit_db`.`t1`.`id` AS `id`,`audit_db`.`t1`.`key1` AS `key1`,`audit_db`.`t1`.`key2` AS `key2`,`audit_db`.`t1`.`key3` AS `key3`,`audit_db`.`t1`.`common_field` AS `common_field` from `audit_db`.`t1` semi join (`audit_db`.`t2`) where ((`audit_db`.`t1`.`key1` = `<subquery2>`.`common_field`) and (`audit_db`.`t2`.`key3` = '100')) |
		+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
		1 row in set (0.00 sec)

		SELECT
			`audit_db`.`t1`.`id` AS `id`,
			`audit_db`.`t1`.`key1` AS `key1`,
			`audit_db`.`t1`.`key2` AS `key2`,
			`audit_db`.`t1`.`key3` AS `key3`,
			`audit_db`.`t1`.`common_field` AS `common_field`
		FROM
			`audit_db`.`t1` semi
		JOIN (`audit_db`.`t2`)
		WHERE
			(
				(
					`audit_db`.`t1`.`key1` = `<subquery2>`.`common_field`
				)
				AND (
					`audit_db`.`t2`.`key3` = '100'
				)
			)
			
	
	我们可以把这个查询理解成：
		对于t1表中的某条记录，如果我们能在t2表（准确的说是执行完WHERE t2.key3 = '100'之后的结果集）中找到一条或多条记录，这些记录的common_field的值等于t1表记录的key1列的值，那么该条t1表的记录就会被加入到最终的结果集。
		
	这个过程其实和把t1和t2两个表连接起来的效果很像：
		SELECT t1.* FROM t1 INNER JOIN t2 ON t1.key1 = t2.common_field WHERE t2.key3 = '100';
	
	只不过我们不能保证对于t1表的某条记录来说，在t2表（准确的说是执行完WHERE t2.key3 = '100'之后的结果集）中有多少条记录满足 t1.key1 = t2.common_field 这个条件，不过我们可以分三种情况讨论：

		情况一：对于t1表的某条记录来说，t1表中没有任何记录满足    t1.key1 = t2.common_field 这个条件，那么该记录自然也不会加入到最后的结果集。

		情况二：对于t1表的某条记录来说，t1表中有且只有1条记录满足 t1.key1 = t2.common_field 这个条件，那么该记录会被加入最终的结果集。

		情况三：对于t1表的某条记录来说，t1表中至少有2条记录满足   t1.key1 = t2.common_field 这个条件，那么该记录会被多次加入最终的结果集。

	
	
	对于t1表的某条记录来说，由于我们只关心t2表中是否存在记录满足 t1.key1 = t2.common_field 这个条件，而不关心具体有多少条记录与之匹配，又因为有情况三的存在，我们上边所说的IN子查询和两表连接之间并不完全等价。  -- 理解了，参考笔记 《2020-07-02-举例说明IN子查询和两表连接之间并不完全等价.sql》
	
	
	但是将子查询转换为连接又真的可以充分发挥优化器的作用，所以设计MySQL的大叔在这里提出了一个新概念 --- 半连接（英文名：semi-join）。
	
	将t1表和t2表进行半连接的意思就是：对于t1表的某条记录来说，我们只关心在t2表中是否存在与之匹配的记录，而不关心具体有多少条记录与之匹配，最终的结果集中只保留t1表的记录。
	
	我们假设MySQL内部是这么改写上边的子查询的：
		SELECT t1.* FROM t1 SEMI JOIN t2
			ON t1.key1 = t2.common_field
			WHERE key3 = '100';	
	
	注意事项：
		semi-join只是在MySQL内部采用的一种执行子查询的方式，MySQL并没有提供面向用户的semi-join语法，所以我们不需要，也不能尝试把上边这个语句放到黑框框里运行，我只是想说明一下上边的子查询在MySQL内部会被转换为类似上边语句的半连接～	
		
		由于相关子查询并不是一个独立的查询，所以不能转换为物化表来执行查询：
			EXPLAIN SELECT * FROM t1 WHERE key1 IN (SELECT key1 FROM t2 WHERE t1.key2 = t2.key2) OR key3 = '3';
		
2.4 semi-join的适用条件

	并不是所有包含IN子查询的查询语句都可以转换为semi-join，只有形如这样的查询才可以被转换为semi-join：

		SELECT ... FROM outer_tables 
			WHERE expr IN (SELECT ... FROM inner_tables ...) AND ...

		SELECT ... FROM outer_tables 
			WHERE (oe1, oe2, ...) IN (SELECT ie1, ie2, ... FROM inner_tables ...) AND ...
	
	
	用文字总结一下，只有符合下边这些条件的子查询才可以被转换为semi-join：

		该子查询必须是和IN语句组成的布尔表达式，并且在外层查询的WHERE或者ON子句中出现。

		外层查询也可以有其他的搜索条件，只不过和IN子查询的搜索条件必须使用AND连接起来。

		该子查询必须是一个单一的查询，不能是由若干查询由UNION连接起来的形式。

		该子查询不能包含GROUP BY或者HAVING语句或者聚集函数。

	... 还有一些条件比较少见，就不唠叨啦～	
	
	
2.5 不适用于semi-join的情况

对于一些不能将子查询转位semi-join的情况，典型的比如下边这几种：

	1. 外层查询的WHERE条件中有其他搜索条件与IN子查询组成的布尔表达式使用OR连接起来

		SELECT * FROM s1 
			WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a')
			OR key2 > 100;
			
	2. 使用NOT IN而不是IN的情况：

		SELECT * FROM s1 
			WHERE key1 NOT IN (SELECT common_field FROM s2 WHERE key3 = 'a')
			
	3. 在SELECT子句中的IN子查询的情况

			SELECT key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a') FROM s1 ;
			
	4. 子查询中包含GROUP BY、HAVING或者聚集函数的情况

		SELECT * FROM s1 
			WHERE key2 IN (SELECT COUNT(*) FROM s2 GROUP BY key1);
			
	5. 子查询中包含UNION的情况

		SELECT * FROM s1 WHERE key1 IN (
			SELECT common_field FROM s2 WHERE key3 = 'a' 
			UNION
			SELECT common_field FROM s2 WHERE key3 = 'b'
		);

2.6 如何优化不能转为semi-join查询的子查询
	MySQL仍然留了两手绝活来优化不能转为semi-join查询的子查询，那就是：
	
	1. 对于不相关子查询来说，可以尝试把它们物化之后再参与查询
		
		另一个案例， 参考笔记 《2020-06-30-explain.sql》 中的《5.5 SUBQUERY 》
		
		比如我们上边提到的这个查询：
			
			SELECT * FROM t1 
				WHERE key1 NOT IN (SELECT common_field FROM t2 WHERE key3 = '100')
			
			root@mysqldb 09:51:  [audit_db]> desc SELECT * FROM t1                                                                 
				-> WHERE key1 NOT IN (SELECT common_field FROM t2 WHERE key3 = '100');
			+----+-------------+-------+------------+------+---------------+----------+---------+-------+-------+----------+-------------+
			| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows  | filtered | Extra       |
			+----+-------------+-------+------------+------+---------------+----------+---------+-------+-------+----------+-------------+
			|  1 | PRIMARY     | t1    | NULL       | ALL  | NULL          | NULL     | NULL    | NULL  | 10212 |   100.00 | Using where |
			|  2 | SUBQUERY    | t2    | NULL       | ref  | idx_key3      | idx_key3 | 403     | const |    40 |   100.00 | NULL        |
			+----+-------------+-------+------------+------+---------------+----------+---------+-------+-------+----------+-------------+
			2 rows in set, 1 warning (0.00 sec)
			
			root@mysqldb 17:57:  [audit_db]> show warnings;
			+-------+------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
			| Level | Code | Message                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
			+-------+------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
			| Note  | 1003 | /* select#1 */ select `audit_db`.`t1`.`id` AS `id`,`audit_db`.`t1`.`key1` AS `key1`,`audit_db`.`t1`.`key2` AS `key2`,`audit_db`.`t1`.`key3` AS `key3`,`audit_db`.`t1`.`common_field` AS `common_field` from `audit_db`.`t1` where (not(<in_optimizer>(`audit_db`.`t1`.`key1`,`audit_db`.`t1`.`key1` in ( <materialize> (/* select#2 */ select `audit_db`.`t2`.`common_field` from `audit_db`.`t2` where (`audit_db`.`t2`.`key3` = '100') having 1 ), <primary_index_lookup>(`audit_db`.`t1`.`key1` in <temporary table> on <auto_key> where ((`audit_db`.`t1`.`key1` = `materialized-subquery`.`common_field`))))))) |
			+-------+------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
			1 row in set (0.00 sec)
			
				SELECT
					`audit_db`.`t1`.`id` AS `id`,
					`audit_db`.`t1`.`key1` AS `key1`,
					`audit_db`.`t1`.`key2` AS `key2`,
					`audit_db`.`t1`.`key3` AS `key3`,
					`audit_db`.`t1`.`common_field` AS `common_field`
				FROM
					`audit_db`.`t1`
				WHERE
					(
						NOT (
							< in_optimizer > (
								`audit_db`.`t1`.`key1`,
								`audit_db`.`t1`.`key1` IN (
									< materialize > (
										/* select#2 */
										SELECT
											`audit_db`.`t2`.`common_field`
										FROM
											`audit_db`.`t2`
										WHERE
											(
												`audit_db`.`t2`.`key3` = '100'
											)
										HAVING
											1
									),
									< primary_index_lookup > (
										`audit_db`.`t1`.`key1` IN < TEMPORARY TABLE > ON < auto_key >
										WHERE
											(
												(
													`audit_db`.`t1`.`key1` = `materialized-subquery`.`common_field`
												)
											)
									)
								)
							)
						)
					) 
				
		先将子查询物化，然后再判断key1是否在物化表的结果集中可以加快查询执行的速度。

		注意事项：请注意这里将子查询物化之后不能转为和外层查询的表的连接，只能是先扫描s1表，然后对s1表的某条记录来说，判断该记录的key1值在不在物化表中。
		
		
	2. 不管子查询是相关的还是不相关的，都可以把IN子查询尝试转为EXISTS子查询

		其实对于任意一个IN子查询来说，都可以被转为EXISTS子查询，通用的例子如下：

			outer_expr IN (SELECT inner_expr FROM ... WHERE subquery_where)
			
		可以被转换为：

			EXISTS (SELECT inner_expr FROM ... WHERE subquery_where AND outer_expr=inner_expr)

		
2.7 小结

	1. 如果IN子查询符合转换为semi-join的条件，查询优化器会优先把该子查询转换为semi-join，然后再考虑下边5种执行半连接的策略中哪个成本最低：

		Table pullout
		DuplicateWeedout
		LooseScan
		Materialization
		FirstMatch
		
		选择成本最低的那种执行策略来执行子查询。

	2. 如果IN子查询不符合转换为semi-join的条件，那么查询优化器会从下边两种策略中找出一种成本更低的方式执行子查询：

		先将子查询物化之后再执行查询
		执行IN to EXISTS转换。

		
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


		
	root@mysqldb 14:43:  [audit_db]> EXPLAIN SELECT * FROM t1 WHERE key1 IN (SELECT key3 FROM t2 WHERE common_field = '100');
	+----+--------------+-------------+------------+--------+---------------+------------+---------+------------------+-------+----------+-------------+
	| id | select_type  | table       | partitions | type   | possible_keys | key        | key_len | ref              | rows  | filtered | Extra       |
	+----+--------------+-------------+------------+--------+---------------+------------+---------+------------------+-------+----------+-------------+
	|  1 | SIMPLE       | t1          | NULL       | ALL    | idx_key1      | NULL       | NULL    | NULL             | 10212 |   100.00 | Using where |
	|  1 | SIMPLE       | <subquery2> | NULL       | eq_ref | <auto_key>    | <auto_key> | 403     | audit_db.t1.key1 |     1 |   100.00 | NULL        |
	|  2 | MATERIALIZED | t2          | NULL       | ALL    | idx_key3      | NULL       | NULL    | NULL             | 10210 |    10.00 | Using where |
	+----+--------------+-------------+------------+--------+---------------+------------+---------+------------------+-------+----------+-------------+
	3 rows in set, 1 warning (0.00 sec)

	root@mysqldb 14:43:  [audit_db]> show warnings;
	+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
	| Level | Code | Message                                                                                                                                                                                                                                                                                                                                                      |
	+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
	| Note  | 1003 | /* select#1 */ select `audit_db`.`t1`.`id` AS `id`,`audit_db`.`t1`.`key1` AS `key1`,`audit_db`.`t1`.`key2` AS `key2`,`audit_db`.`t1`.`key3` AS `key3`,`audit_db`.`t1`.`common_field` AS `common_field` from `audit_db`.`t1` semi join (`audit_db`.`t2`) where ((`<subquery2>`.`key3` = `audit_db`.`t1`.`key1`) and (`audit_db`.`t2`.`common_field` = '100')) |
	+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
	1 row in set (0.00 sec)

		SELECT
			`audit_db`.`t1`.`id` AS `id`,
			`audit_db`.`t1`.`key1` AS `key1`,
			`audit_db`.`t1`.`key2` AS `key2`,
			`audit_db`.`t1`.`key3` AS `key3`,
			`audit_db`.`t1`.`common_field` AS `common_field`
		FROM
			`audit_db`.`t1` semi JOIN (`audit_db`.`t2`)
		WHERE
		(
			(
				`<subquery2>`.`key3` = `audit_db`.`t1`.`key1`
			)
			AND (
				`audit_db`.`t2`.`common_field` = '100'
			)
		)

	
	-- 这里使用不上 semi join
	root@mysqldb 14:27:  [audit_db]> EXPLAIN SELECT * FROM t1 WHERE key1 IN (SELECT key1 FROM t2) OR key3 = '3';
	+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
	| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows  | filtered | Extra       |
	+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
	|  1 | PRIMARY     | t1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 10212 |   100.00 | Using where |
	|  2 | SUBQUERY    | t2    | NULL       | index | idx_key1      | idx_key1 | 403     | NULL | 10210 |   100.00 | Using index |
	+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
	2 rows in set, 1 warning (0.00 sec)
	
	对于包含子查询的查询语句来说，就可能涉及多个SELECT关键字，所以在包含子查询的查询语句的执行计划中，每个SELECT关键字都会对应一个唯一的id值;
	从输出结果中我们可以看到，t1表在外层查询中，外层查询有一个独立的SELECT关键字，所以第一条记录的id值就是1，t2表在子查询中，子查询有一个独立的SELECT关键字，所以第二条记录的id值就是2。
	
	
	root@mysqldb 16:48:  [audit_db]> show warnings;
	+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
	| Level | Code | Message                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
	+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
	| Note  | 1003 | /* select#1 */ select `audit_db`.`t1`.`id` AS `id`,`audit_db`.`t1`.`key1` AS `key1`,`audit_db`.`t1`.`key2` AS `key2`,`audit_db`.`t1`.`key3` AS `key3`,`audit_db`.`t1`.`common_field` AS `common_field` from `audit_db`.`t1` where (<in_optimizer>(`audit_db`.`t1`.`key1`,`audit_db`.`t1`.`key1` in ( <materialize> (/* select#2 */ select `audit_db`.`t2`.`key1` from `audit_db`.`t2` where 1 ), <primary_index_lookup>(`audit_db`.`t1`.`key1` in <temporary table> on <auto_key> where ((`audit_db`.`t1`.`key1` = `materialized-subquery`.`key1`))))) or (`audit_db`.`t1`.`key3` = '3')) |
	+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
	1 row in set (0.00 sec)
		
		SELECT
			`audit_db`.`t1`.`id` AS `id`,
			`audit_db`.`t1`.`key1` AS `key1`,
			`audit_db`.`t1`.`key2` AS `key2`,
			`audit_db`.`t1`.`key3` AS `key3`,
			`audit_db`.`t1`.`common_field` AS `common_field`
		FROM
			`audit_db`.`t1`
		WHERE
			(
				< in_optimizer > (
					`audit_db`.`t1`.`key1`,
					`audit_db`.`t1`.`key1` IN (
						< materialize > (
							/* select#2 */
							SELECT
								`audit_db`.`t2`.`key1`
							FROM
								`audit_db`.`t2`
							WHERE
								1
						),
						< primary_index_lookup > (
							`audit_db`.`t1`.`key1` IN < TEMPORARY TABLE > ON < auto_key >
							WHERE
								(
									(
										`audit_db`.`t1`.`key1` = `materialized-subquery`.`key1`
									)
								)
						)
					)
				)
				OR (`audit_db`.`t1`.`key3` = '3')
			) 
		
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
			